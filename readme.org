#+TITLE: Mitch Kyle's Emacs 26 Configuration
#+AUTHOR: Mitch Kyle
#+EMAIL: mitch.tux@gmail.com

* What's All This Then?
This is a configuration file for Emacs.

Inspired by [[http://aaronbedra.com/emacs.d/][Aaron Bedra's config]] with elements taken from [[https://github.com/bbatsov/prelude][prelude]].

This is a [[https://en.wikipedia.org/wiki/Literate_programming][literate program]] which sits at =~/.emacs.d/readme.org= and
compiles to =~/.emacs.d/init.el{,c}=. Recompile by running =mkyle/rebuild-init-file=.

I named this file =readme.org= so it will show up on the GitHub repo landing page and the idea of
having a literate program called "readme" amuses me slightly.

The language in this document is informal written as me the writer to you the reader (who is
probably me in the future /shout-out)

** Installation
pretty straight-forward
#+BEGIN_EXAMPLE
git clone https://github.com/mitch-kyle/emacs-config.git ~/.emacs.d
#+END_EXAMPLE

** Questions?
One of the purposes of this document is to provide information along with the configuration. It was however,
hastily written. I suspect a lot of it does not make sense. Feel free to open issues asking for clarification
or pointing out typos or nonsense and I'll try to help and improve the document as I go.

* Table Of Contents                                                   :TOC_2:
- [[#whats-all-this-then][What's All This Then?]]
  - [[#installation][Installation]]
  - [[#questions][Questions?]]
- [[#early-init][Early Init]]
  - [[#garbage-collection][Garbage Collection]]
  - [[#defer-filename-handlers][Defer Filename Handlers]]
  - [[#maximize-screen-space][Maximize Screen Space]]
  - [[#disable-modeline][Disable Modeline]]
  - [[#short-answers][Short Answers]]
  - [[#silence-redefinition-warnings][Silence Redefinition Warnings]]
  - [[#early-init-footer][Early Init Footer]]
- [[#platform][Platform]]
  - [[#package-manager---straightel][Package Manager - straight.el]]
  - [[#package-configuration---use-package][Package Configuration - use-package]]
  - [[#org-early-load][Org Early Load]]
  - [[#compiling-this-project][Compiling this Project]]
  - [[#executable-path][Executable Path]]
  - [[#manage-config-directory][Manage Config Directory]]
- [[#look-and-feel][Look And Feel]]
  - [[#theme][Theme]]
  - [[#mode-line][Mode Line]]
  - [[#fonts][Fonts]]
  - [[#ease-of-use][Ease Of Use]]
  - [[#navigation][Navigation]]
  - [[#editing][Editing]]
  - [[#x-windows][X Windows]]
- [[#language-specific-packages][Language Specific Packages]]
  - [[#org-mode][Org Mode]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#conf-files][Conf Files]]
  - [[#clojure][Clojure]]
  - [[#cmake][CMake]]
  - [[#javascript][JavaScript]]
  - [[#scheme][Scheme]]
  - [[#groovy][Groovy]]
  - [[#docker][Docker]]
  - [[#yaml][YAML]]
  - [[#markdown][Markdown]]
  - [[#lua][Lua]]
  - [[#zsh][Zsh]]
  - [[#terraform][Terraform]]
- [[#software-distribution-specific-packages][Software Distribution Specific Packages]]
  - [[#arch][Arch]]
  - [[#guix][Guix]]
- [[#miscellaneous-packages][Miscellaneous Packages]]
  - [[#git][Git]]
  - [[#restclient][Restclient]]
  - [[#irc][IRC]]
  - [[#persistent-scratch][Persistent Scratch]]
  - [[#terminal][Terminal]]
  - [[#external-applications][External Applications]]
  - [[#window-manager---exwm][Window Manager - EXWM]]
- [[#user-script-directory][User Script Directory]]
- [[#footer][Footer]]
- [[#tasks][Tasks]]
  - [[#recompile-on-save][Recompile on save]]

* Early Init
Things we want to do before configuring package management
#+BEGIN_SRC emacs-lisp :tangle early-init.el
;;; init.el --- emacs early initialization -*- lexical-binding: t; -*-
;;; Commentary:
;; Generated file. do not edit. changes may be overwritten
;;; Code:
#+END_SRC

** Garbage Collection
Wait until after startup to garbage collect as per, [How does Doom start so quickly?](https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly)
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq gc-cons-threshold  most-positive-fixnum ; 2^61 bytes
      gc-cons-percentage 0.6)
#+END_SRC

Once startup is finished, reset gc threshold to something sensible to prevent freezes
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold  33554432 ;32M
                  gc-cons-percentage 0.1)))
#+END_SRC

** Defer Filename Handlers
Prevent looking up file name handlers until after startup
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(let ((saved-file-name-handler-alist file-name-handler-alist))
  (setq file-name-handler-alist nil)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq file-name-handler-alist
                    (append saved-file-name-handler-alist
                            file-name-handler-alist)))))
#+END_SRC

** Maximize Screen Space
Remove the different bars taking up valuable working space. Remove these in early init to prevent them being drawn.
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Disable Modeline
Disable modeline until we apply our sugar later
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq mode-line-format nil)
#+END_SRC

** Short Answers
Use 'y' or 'n' rather than 'yes' or 'no'. This should improve productivity when answering binary questions by up
to 60% according to Homer Simpson.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Silence Redefinition Warnings
Prevent warnings when advice is added to functions.
[[https://andrewjamesjohnson.com/suppressing-ad-handle-definition-warnings-in-emacs/][More Information]]
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq ad-redefinition-action 'accept)
#+END_SRC

** Early Init Footer
#+BEGIN_SRC emacs-lisp :tangle early-init.el
;; early-init.el ends here
#+END_SRC

* Platform
The init file begins here. first setup package management and define config file compilation.

First, add an emacs lisp header to the generated file with an explanation that it is a generated file
#+BEGIN_SRC emacs-lisp :tangle init.el
;;; init.el --- emacs initialization -*- lexical-binding: t; -*-
;;; Commentary:
;; Generated file. do not edit. changes may be overwritten
;;; Code:
#+END_SRC

** Package Manager - straight.el
A functional package manager for emacs. See [[https://github.com/raxod502/straight.el][straight.el github]]
#+BEGIN_SRC emacs-lisp :tangle init.el
(defvar bootstrap-version)
(defvar straight-repository-branch "develop")
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC

** Package Configuration - use-package
[[https://github.com/jwiegley/use-package][use-package]] is a feature-rich package configuration tool. In the event of error during package configuration,
it doesn't prevent the rest of your configuration from loading. Set it to use straight.el by default.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq straight-use-package-by-default t)
(straight-use-package 'use-package)
(require 'bind-key)
#+END_SRC

** Org Early Load
Because straight.el can't properly compile org yet, we need to define the org-version function
ourselves to prevent the old builtin org from being loaded instead.

#+BEGIN_SRC emacs-lisp :tangle init.el :noweb yes
(use-package git)
(when (require 'git nil t)
  (defun org-git-version ()
    "The Git version of org-mode.
Inserted by installing org-mode or when a release is made."
    (let ((git-repo (expand-file-name "straight/repos/org/"
                                      user-emacs-directory)))
      (string-trim
       (git-run "describe"
                "--match=release\*"
                "--abbrev=6"
                "HEAD"))))

  (defun org-release ()
    "The release version of org-mode.
Inserted by installing org-mode or when a release is made."
    (let ((git-repo (expand-file-name "straight/repos/org/"
                                      user-emacs-directory)))
      (string-trim
       (string-remove-prefix
        "release_"
        (git-run "describe"
                 "--match=release\*"
                 "--abbrev=0"
                 "HEAD")))))

  (provide 'org-version))

<<load-org>>
#+END_SRC

** Compiling this Project
A function to rebuild this project if it's changed since the last time it was built.
#+BEGIN_SRC emacs-lisp :tangle init.el
(with-eval-after-load 'org
  (defun mkyle/rebuild-init-file ()
    "Rebuild init files if they've changed since the last time it was built."
    (interactive)
    (org-babel-tangle-file (expand-file-name "readme.org"
                                             user-emacs-directory)
                           "emacs-lisp")
    (byte-compile-file (expand-file-name "early-init.el"
                                         user-emacs-directory))
    (byte-compile-file (expand-file-name "init.el"
                                         user-emacs-directory))
    (org-babel-tangle-file (expand-file-name "window-manager.org"
                                             user-emacs-directory)
                           "emacs-lisp")
    (byte-compile-file (expand-file-name "window-manager.el"
                                         user-emacs-directory))))
#+END_SRC

** Executable Path
Set the path to the environment variable PATH always
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package exec-path-from-shell
  :custom
  (exec-path-from-shell-arguments   nil)
  (exec-path-from-shell-shell-name "/bin/sh")
  :config
  (exec-path-from-shell-initialize))
#+END_SRC

** Manage Config Directory
*** No Litter
Keep =~/.emacs.d= clean. some libraries create variable files and/or additional configuration files
in the emacs user directory; no-littering puts most of these files in =~/.emacs.d/var= and =~/.emacs.d/etc=
respectively.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package no-littering
  :ensure t)
#+END_SRC

*** Custom
Use a separate file for custom modifications so they are not overwritten in init.el
#+BEGIN_SRC emacs-lisp :tangle init.el
(with-eval-after-load 'no-littering
  (let ((base-custom-file (expand-file-name "custom" no-littering-etc-directory)))
    (setq-default custom-file (concat base-custom-file ".el"))
    (load base-custom-file t)))
#+END_SRC

Compile custom file when it changes.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defadvice custom-save-all (after mkyle/recompile-custom-file-on-save () activate)
  "Recompile custom files after saving to it"
  (byte-compile-file custom-file))
#+END_SRC

* Look And Feel

** Theme
*** Theme Hook
There's no hook that runs after a theme is enabled so lets make one.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defvar mkyle/after-enable-theme-hook nil
  "Hook to run after a theme is enabled.")

(advice-add 'enable-theme :after
            (lambda (theme)
              (unless (eq theme 'user)
                (run-hooks 'mkyle/after-enable-theme-hook)))
            '((name . mkyle/after-enable-theme-hook)))
#+END_SRC

*** Settings
This is where we load the theme, it handles colors and text effects
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package monokai-theme
  :straight (monokai-theme :type git
                           :host github
                           :repo "mitch-kyle/monokai-emacs")
  :ensure t
  :config (load-theme 'monokai t))
#+END_SRC

** Mode Line
The modeline displays information about the buffer like buffer name and what modes are currently active
between the window and the minibuffer.

*** Hide Minor Modes
Mode line is for showing all the active modes. Some of these are not useful so let's hide them.
This adds the =:diminish= key to =use-package= which will hide the minor-mode associated with the package.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package diminish :defer t)
#+END_SRC

*** Search Results
Show total number of search matches and the current match index in the modeline
See [[https://github.com/syohex/emacs-anzu][emacs-anzu]]
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package anzu
  :diminish anzu-mode
  :config (global-anzu-mode t))
#+END_SRC

*** Buffer Information
Show buffer size
#+BEGIN_SRC emacs-lisp :tangle init.el
(size-indication-mode t)
#+END_SRC

Show cursor position in buffer
#+BEGIN_SRC emacs-lisp :tangle init.el
(line-number-mode t)
(column-number-mode t)
#+END_SRC

*** Spaceline
Spaceline is a nice looking mode line package based on powerline from the
[[http://spacemacs.org/][spacemacs]] distribution
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package spaceline
  :config
  (progn
    (require 'spaceline)
    (require 'spaceline-segments)

    (setq-default anzu-cons-mode-line-p           nil
                  powerline-default-separator     'contour
                  spaceline-minor-modes-separator " ")

    ;; Projectile doesn't really fit with the other minor modes
    ;; but the menu might be useful. let's move it to it's own
    ;; segment
    (spaceline-define-segment mkyle/projectile
      "Display project name with projectile menu"
      (when (and (boundp projectile-project-root)
                 (projectile-project-root))
        (propertize (projectile-project-name)
                    'local-map (let ((map (make-sparse-keymap)))
                                 (define-key map [mode-line down-mouse-1]
                                   projectile-mode-menu)
                                 map)
                    'mouse-face 'mode-line-highlight)))


    (defun mkyle/spaceline-reset ()
      (spaceline-compile)
      (setq-default mode-line-format
                    '("%e" (:eval (spaceline-ml-main)))))

    (defun mkyle/spaceline-theme (&rest additional-segments)
      "Spaceline emacs theme with some tweaks"
      (spaceline-compile
        `((((((persp-name :fallback workspace-number) window-number)
             :separator "•")
            buffer-modified
            buffer-size)
           :face highlight-face
           :priority 100)
          (anzu :priority 95)
          auto-compile
          ((buffer-id remote-host)
           :priority 98)
          (major-mode :priority 79)
          (process :when active)
          ((flycheck-error flycheck-warning flycheck-info)
           :when active
           :priority 89)
          (minor-modes :when active
                       :priority 9)
          (mu4e-alert-segment :when active)
          (erc-track :when active)
          (version-control :when active
                           :priority 78)
          (mkyle/projectile :priority 20)
          (org-pomodoro :when active)
          (org-clock :when active)
          nyan-cat)
        `(which-function
          (python-pyvenv :fallback python-pyenv)
          (purpose :priority 94)
          (battery :when active)
          (selection-info :priority 95)
          input-method
          ((point-position line-column)
           :separator " • "
           :priority 96)
          ((buffer-encoding-abbrev)
           :priority 9)
          (global :when active)
          ,@additional-segments
          (buffer-position :priority 99)
          (hud :priority 99)))
      (setq-default mode-line-format
                    '("%e" (:eval (spaceline-ml-main)))))

    (mkyle/spaceline-theme)
    (add-hook 'mkyle/after-enable-theme-hook 'mkyle/spaceline-reset)))
#+END_SRC

** Fonts
[[http://terminus-font.sourceforge.net/][Terminus Font]] is designed for terminals and source code.
#+BEGIN_SRC emacs-lisp :tangle init.el
(when (member "Terminus" (font-family-list))
  (set-frame-font "Terminus 12" nil (frame-list)))
#+END_SRC

Add font with better unicode coverage.
#+BEGIN_SRC emacs-lisp :tangle init.el
(when (member "Symbola" (font-family-list))
  (set-fontset-font t 'unicode "Symbola" nil 'prepend))
#+END_SRC

*** Emojis
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package emojify
  :init (defvar emojify-display-style 'unicode))
#+END_SRC

** Ease Of Use
These don't really fit anywhere else but they are essential to make emacs not feel ancient and esoteric

*** Remove Startup Clutter
The startup screen has some nice information for new users but it's in the way.
Same with the scratch buffer explanation.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq inhibit-startup-screen            t
      initial-scratch-message           nil)

;; Display a fortune instead of the welcome to emacs message
(defun display-startup-echo-area-message ()
  (when (executable-find "fortune")
    (message "%s" (substring (shell-command-to-string "fortune -sa") 0 -1))))
#+END_SRC

*** Large File Warning
warn when opening files bigger than 100MB
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq-default large-file-warning-threshold 104857600)
#+END_SRC

*** Disable Blinking Cursor
In theory the blinking cursor could be a conservation tool; consume only half of the power of a static cursor.
In practice, it's just a pain.
#+begin_src
(blink-cursor-mode -1)
#+END_SRC

*** Show Keybindings
show available keybindings after you start typing
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package which-key
  :diminish which-key-mode
  :config (which-key-mode +1))
#+END_SRC

*** Open File At Point
Open file with emacsclient with cursors positioned on requested line.
Most of console-based utilities prints filename in format
'filename:linenumber'.  So you may wish to open filename in that format.
Just call:
#+begin_src
emacsclient filename:linenumber
#+END_SRC

to open 'filename' and set the cursor on line 'linenumber'.
From: [[https://github.com/bbatsov/prelude][prelude]]

#+BEGIN_SRC emacs-lisp :tangle init.el
(defadvice server-visit-files (before parse-numbers-in-lines
                                      (files proc &optional nowait)
                                      activate)
  "Open file with emacsclient with cursors positioned on requested line.
Most of console-based utilities prints filename in format
'filename:linenumber'.  So you may wish to open filename in that format.
Just call:

  emacsclient filename:linenumber

to open 'filename' and set the cursor on line 'linenumber'."
  (ad-set-arg 0
              (mapcar (lambda (fn)
                        (let ((name (car fn)))
                          (if (string-match
                               "^\\(.*?\\):\\([0-9]+\\)\\(?::\\([0-9]+\\)\\)?$"
                               name)
                              (cons
                               (match-string 1 name)
                               (cons (string-to-number (match-string 2 name))
                                     (string-to-number
                                      (or (match-string 3 name)
                                          ""))))
                            fn)))
                      files)))
#+END_SRC

*** Titles
**** Set Frame Title Format
The frame is the whole external "emacs window", not to be confused with a window within emacs which displays
a buffer. An emacs instance may have multiple frames and a frame may have multiple windows. This sets the
title of the window to the filename of the active buffer if available otherwise the buffer name.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq frame-title-format
      '("" invocation-name " - "
        (:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))
#+END_SRC

**** Buffer Titles
Rename buffers with the same file name to something useful
#+BEGIN_SRC emacs-lisp :tangle init.el
(when (require 'uniquify nil t)
  (setq uniquify-buffer-name-style   'forward
        uniquify-separator           "/"
        ;; rename after killing uniquified
        uniquify-after-kill-buffer-p t
        ;; ignore system buffers
        uniquify-ignore-buffers-re   "^\\*"))
#+END_SRC

*** Reload When Files Change
When underlying files change, revert buffers automatically.
#+BEGIN_SRC emacs-lisp :tangle init.el
(global-auto-revert-mode t)
#+END_SRC

*** Save Command History
Remember most recently run commands and text searches
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package savehist
  :config (savehist-mode 1))
#+END_SRC

*** Splitting Windows
Prefer to split vertically rather than horizontally. Shamelessly stolen from stack overflow years ago.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun mkyle/split-window (&optional window)
  "Split window more senibly.  WINDOW."
  (let ((window (or window (selected-window))))
    (or (and (window-splittable-p window t)
             ;; Split window horizontally.
             (with-selected-window window
               (split-window-right)))
        (and (window-splittable-p window)
             ;; Split window vertically.
             (with-selected-window window
               (split-window-below)))
        (and (eq window (frame-root-window (window-frame window)))
             (not (window-minibuffer-p window))
             ;; If WINDOW is the only window on its frame and is not the
             ;; minibuffer window, try to split it horizontally disregarding
             ;; the value of `split-width-threshold'.
             (let ((split-width-threshold 0))
               (when (window-splittable-p window t)
                 (with-selected-window window
                   (split-window-right))))))))

(setq-default split-window-preferred-function #'mkyle/split-window)
#+END_SRC

*** Finding the Cursor
Show the cursor when moving after big movements in the window
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package beacon
  :diminish beacon-mode
  :config (beacon-mode +1))
#+END_SRC
*** Remove suspend-frame keybinding
This keybinding makes sense for a terminal editor but occasionally I hit it by accident while using exwm and it just destroys one's train of thought.
#+BEGIN_SRC emacs-lisp :tangle init.el
(global-unset-key (kbd "C-x C-z"))
#+END_SRC

*** Scrolling
Maintain cursor position when scrolling
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq scroll-margin                   0
      scroll-conservatively           100000
      scroll-preserve-screen-position 1)
#+END_SRC
*** Line Numbers
Always show line numbers
#+BEGIN_SRC emacs-lisp :tangle init.el
(global-linum-mode t)
#+END_SRC

** Navigation
*** List Buffers - IBuffer
List buffers with C-x C-b. The default emacs buffer list leaves much to be desired; IBuffer is a good alternative.
#+BEGIN_SRC emacs-lisp :tangle init.el
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
(with-eval-after-load 'ibuffer
  (add-hook 'ibuffer-mode-hook 'ibuffer-auto-mode))

(use-package ibuffer
  :hook
  ;; Update list when ibuffer gets focus
  (ibuffer-mode-hook ibuffer-auto-mode)
  :commands (ibuffer)
  :config
  ;; increase buffer name column width
  (setq ibuffer-formats '((mark modified read-only " "
                                ;; 40 40 is the column width
                                (name 40 40 :left :elide) " "
                                (size 9 -1 :right) " "
                                (mode 8 8 :left :elide) " "
                                filename-and-process)
                          (mark " " (name 16 -1) " " filename))))
#+END_SRC

**** IBuffer Filter Groups
Organize the list of buffers by group. Dynamic groups allow this list to be generated and for it to be extended
by other packages (like ibuffer-projectile)
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package ibuffer-dynamic-groups
  :after ibuffer
  :straight (ibuffer-dynamic-groups :type git
                                    :host github
                                    :repo "mitch-kyle/ibuffer-dynamic-groups")
  :config (progn
            (setq ibuffer-show-empty-filter-groups nil)
            (ibuffer-dynamic-groups-add
             (lambda (groups)
               (append groups
                       '(("System" (name . "^\\*.*\\*$")))))
             '((name . system-group)))
            (ibuffer-dynamic-groups t)))
#+END_SRC

*** List Options When Doing Things - Ivy
Better minibuffer interactive completion

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package smex) ;; Completion History

(use-package ivy
  :straight (swiper :type git
                    :host github
                    :repo "abo-abo/swiper"
                    :files (:defaults (:exclude "ivy-hydra.el")))
  :ensure t
  :after smex
  :diminish (counsel-mode ivy-mode)
  :init (setq ivy-use-virtual-buffers       nil
              enable-recursive-minibuffers  t
              ;; Enable fuzzy matching except in swiper
              ivy-re-builders-alist         '((t      . ivy--regex-ignore-order)
                                              (swiper . ivy--regex-plus))
              ivy-wrap                      t
              ivy-use-selectable-prompt     t
              projectile-completion-system  'ivy
              ivy-initial-inputs-alist      nil
              ivy-count-format              "%d/%d ")
  :bind (:map ivy-mode-map
              ("C-c C-r" . ivy-resume)
              :map global-map
              ("C-s" . swiper)
              :map ivy-minibuffer-map
              ("<return>"   . ivy-alt-done) ;; Complete directory like ido
              ("M-<return>" . ivy-done))
  :config
  ;; Remove the org-mode face that messes up formatting
  (setq ivy-switch-buffer-faces-alist
        (assq-delete-all 'org-mode ivy-switch-buffer-faces-alist)))

;; Add info to ivy buffer
(use-package ivy-rich
  :ensure t
  :after ivy
  :config (ivy-rich-mode +1))

;; Something is enabling ido at startup and I can't find it
;; so hack is off after startup
(add-hook 'emacs-startup-hook
          (lambda ()
            (counsel-mode +1)
            (ivy-mode +1)
            (ido-mode -1)))
#+END_SRC

*** Direct Based Window Navigation - Windmove
Switch windows in the direct of the arrow keys. (s-<arrow>). (C-c <arrow>) in the terminal because modifiers on arrow keys aren't always supported
#+BEGIN_SRC emacs-lisp :tangle init.el
(windmove-default-keybindings)

(progn
  (global-set-key [s-left]  'windmove-left)
  (global-set-key [s-right] 'windmove-right)
  (global-set-key [s-up]    'windmove-up)
  (global-set-key [s-down]  'windmove-down))

(unless window-system
  (global-set-key (kbd "C-c <left>")  'windmove-left)
  (global-set-key (kbd "C-c <right>") 'windmove-right)
  (global-set-key (kbd "C-c <up>")    'windmove-up)
  (global-set-key (kbd "C-c <down>")  'windmove-down))
#+END_SRC

** Editing
*** Keep Directories Clean
emacs creates these annoy =.#filename= lock files in the directory of
the file being edited. When there's only one user on the system
they're mostly just a pain.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq-default create-lockfiles nil)
#+END_SRC

Auto-save creates =#filename#= files in the directory of the file being edited;
this interferes with just about everything so let's move them to the variable
directory.
#+BEGIN_SRC emacs-lisp :tangle init.el
(with-eval-after-load 'no-littering
  (setq-default auto-save-file-name-transforms
                `((".*" ,no-littering-var-directory t))))
#+END_SRC

*** Project Management - Projectile
A set of commands for editing files as part of a project
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package projectile
  :diminish projectile-mode
  :config (progn
            (global-set-key (kbd "C-c p") projectile-command-map)
            (projectile-mode t)))
#+END_SRC

**** Projectile IBuffer Groups
Group files by project in ibuffer
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package ibuffer-projectile
  :after (:all projectile ibuffer-dynamic-groups)
  :config
  (progn
    (setq ibuffer-projectile-prefix "- ")
    (with-eval-after-load 'ibuffer-dynamic-groups
      (ibuffer-dynamic-groups-add
       (lambda (groups)
         (append (ibuffer-projectile-generate-filter-groups)
                 groups))
       '((name . projectile-groups)
         (depth . -50))))))
#+END_SRC

*** Edit Remote Files - Tramp
Tramp is useful for editing files on remote systems or for editing files as a different user such as root

Just open the remote file like:
#+BEGIN_EXAMPLE
ssh:user@example.com:/path/to/file
#+END_EXAMPLE

Or the permission protected file:
#+BEGIN_EXAMPLE
sudo:root@localhost:/path/to/file
#+END_EXAMPLE

*** Sane Basic Editing Keybindings
Make C-[x,c,v] work how you would expect in a text editor. /with-love
#+BEGIN_SRC emacs-lisp :tangle init.el
(cua-mode t)
#+END_SRC

*** Rainbow Delimiters
Give nested delimiters (=()[]{}<>=) different colours. It is more valuable than gold

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package rainbow-delimiters
  :commands (rainbow-delimiters-mode)
  :hook ((prog-mode) . rainbow-delimiters-mode))
#+END_SRC

*** Tab Behaviour
Use spaces instead of tabs
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq-default indent-tabs-mode  nil
              tab-width         4
              tab-always-indent 'complete)
#+END_SRC

*** Keep Whitespace Clean
Make whitespace uniform when saving a file. So if a line contains a mix of tabs and
spaces, this will replace it with "appropriate" whitespace symbols
#+BEGIN_SRC emacs-lisp :tangle init.el
(add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC

*** Selecting Text
When you type over marked text, it should delete the text. In every other
editor it would but with emacs we have to tell it to first
#+begin_src
(delete-selection-mode t)
#+END_SRC

*** Autocomplete Dropdown
Company is your general purpose autocomplete dropdown. enable it always
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package company
  :diminish company-mode
  :config
  (progn
    (setq company-idle-delay 0.5
          company-show-numbers t
          company-tooltip-limit 10
          company-minimum-prefix-length 2
          company-tooltip-align-annotations t
          ;; invert the navigation direction if the the completion popup-isearch-match
          ;; is displayed on top (happens near the bottom of windows)
          company-tooltip-flip-when-above t)
    (global-company-mode 1)))
#+END_SRC

*** Highlighting
**** Search Results
Highlight search results
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq-default search-highlight t
              query-replace-highlight t)
#+END_SRC

**** Matching Delimiters - show-paren
Highlight matching parens.
#+BEGIN_SRC emacs-lisp :tangle init.el
(show-paren-mode t)
#+END_SRC

**** Rainbow Mode
Highlight strings which probably represent a colour as the colour they probably represent.
e.g red DarkGreen, #2449FC
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package rainbow-mode
  :defer t
  :commands rainbow-mode
  :diminish rainbow-mode)
#+END_SRC

**** Matching Symbols
Underline other occurrences of a symbol under the cursor
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package highlight-symbol
  :hook ((prog-mode) . highlight-symbol-mode)
  :diminish highlight-symbol-mode
  :config (set-face-attribute 'highlight-symbol-face nil
                              :background nil
                              :underline t))
#+END_SRC

*** Spell Checking - flyspell
A minor mode for spell checking. When enabled use =C-c $= to correct word.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package flyspell
  :commands flyspell-mode
  :config
  (setq-default flyspell-issue-welcome-flag nil
                flyspell-issue-message-flag nil
                ispell-program-name         "/usr/bin/aspell"
                ispell-list-command         "list"))
#+END_SRC

*** Code Snippets - yasnippets
Auto fill common code blocks
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package yasnippet
  :bind (:map yas-minor-mode-map
              ("C-`" . yas-expand)
              ("C-/" . yas-insert-snippet))
  :commands yas-minor-mode)

(use-package yasnippet-snippets
  :after yasnippets)
#+END_SRC

** X Windows
*** Window Divider
Make the vertical window divider available but only one pixel wide
#+BEGIN_SRC emacs-lisp :tangle init.el
(when window-system
  (setq-default window-divider-default-right-width 1)
  (window-divider-mode t))
#+END_SRC

*** Transparency
I like the "glass editing window" effect. This sets it that way by default and gives a function to toggle it.
#+BEGIN_SRC emacs-lisp :tangle init.el
(when window-system
  (defun mkyle/toggle-transparency ()
    "Toggle off window transparency"
    (interactive)
    (set-frame-parameter nil 'alpha
                         (if (eql (car (frame-parameter nil 'alpha))
                                  100)
                             '(95 . 95)
                           '(100 . 100))))
  (set-frame-parameter nil 'alpha '(95 . 95))
  ;; Make new frame transparent because we don't always inherit
  (add-to-list 'after-make-frame-functions
               (lambda (&rest _)
                 (set-frame-parameter nil 'alpha '(95 . 95)))))
#+END_SRC

* Language Specific Packages
Packages related to editing different file formats

** Org Mode
Org mode is used to build this document.
#+NAME: load-org
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-plus-contrib
    :mode ("\\.org\\'" . org-mode)
    :init (progn (setq org-directory                    "~/org"
                       org-adapt-indentation            nil
                       org-edit-src-content-indentation 0)
                 (mkdir org-directory t))
    :config
    (progn
      (require 'org-eldoc)
      (org-eldoc-load)
      (advice-add 'org-eldoc-documentation-function :before-until
                  (lambda (&rest _)
                    (when-let (link
                               (org-element-property :raw-link
                                                     (org-element-context)))
                      (format "Link: %s" link)))
                  '((name  . mkyle/show-link-in-minibuffer)
                    (depth . 100)))
      (add-hook 'org-mode-hook 'flyspell-mode)
      (add-hook 'org-mode-hook 'yas-minor-mode)))

  (use-package toc-org
    :after org
    :hook ((org-mode) . toc-org-mode))
#+END_SRC

** Emacs Lisp
Extension language for emacs. Most useful packages for elisp are included with vanilla emacs

*** Documentation
Show documentation in the minibuffer for symbol under cursor
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package eldoc
  :diminish eldoc-mode
  :hook ((emacs-lisp-mode) . eldoc-mode)
  :config (global-eldoc-mode +1))
#+END_SRC

*** Autocompile
Automatically compile emacs lisp files from the user configuration directory =~/.emacs.d=.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package auto-compile
  :config
  (progn
    (setq auto-compile-display-buffer    nil
          auto-compile-mode-line-counter t)
    (auto-compile-on-load-mode +1)
    (auto-compile-on-save-mode +1)))
#+END_SRC

** Conf Files
Syntax highlighting for unix config files
#+BEGIN_SRC emacs-lisp :tangle init.el
(mapc (lambda (filename-regex)
        (add-to-list 'auto-mode-alist `(,filename-regex . conf-mode)))
      (list "\\.conf\\'"
            "\\.desktop\\'"
            "\\.service\\'"))
#+END_SRC

** Clojure
A more opinionated scheme for jvm written by Rich Hickey. Some said it wasn't possible to make a more
particular scheme; Rich disagrees.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package clojure-mode
  :mode ("\\.edn\\'" "\\.clj\\'")
  :config (add-hook 'clojure-mode-hook 'subword-mode))
#+END_SRC

*** Cider
Cider is a featureful repl for clojure development
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package cider
  :defer t
  :config (progn
            (setq nrepl-log-messages                   t
                  cider-inject-dependencies-at-jack-in t)
            (add-hook 'cider-mode-hook      'eldoc-mode)
            (add-hook 'cider-repl-mode-hook 'subword-mode)
            (add-hook 'cider-repl-mode-hook 'rainbow-delimiters-mode)

            (define-key cider-mode-map (kbd "C-c f") 'cider-find-var)

            (with-eval-after-load 'ibuffer-dynamic-groups
              (ibuffer-dynamic-groups-add
               (lambda (groups)
                 (append '(("Cider" (or (name . "^\\*nrepl-.*\\*$")
                                        (name . "^\\*cider-.*\\*$"))))
                         groups))
               '((name . cider-group)
                 (depth . -1))))))
#+END_SRC

** CMake
It's like make only less accessible to new users. you're welcome. - GNU, probably
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package cmake-mode
  :mode ("CMakeLists\\.txt\\'" "\\.cmake\\'")
  :config (add-hook 'cmake-mode-hook 'yas-minor-mode))
#+END_SRC

** JavaScript
The most fully featured language for running in the web browser and I wish I was joking.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package js2-mode
  :mode ("\\.js\\'" "\\.pac\\'")
  :interpreter "node")

(use-package json-mode
  :mode "\\.json\\'")
#+END_SRC

** Scheme
Like clojure but old. GNU's trying to bring it back with GNU/Guile. power to them.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package scheme
  :mode ("\\.scm\\'" . scheme-mode))
#+END_SRC

You really need to have a repl open when editing scheme files. Geiser is a nice one for emacs. invoke with =geiser=
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package geiser
  :defer t
  :config (setq geiser-mode-start-repl-p t))
#+END_SRC

** Groovy
Don't get much use out of groovy syntax highlighting but it's useful for editing Jenkinsfiles
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package groovy-mode
  :mode ("\\.groovy\\'" "JenkinsFile\\'"))
#+END_SRC

** Docker
Dockerfile syntax highlighting
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package dockerfile-mode
  :mode "Dockerfile\\'")
#+END_SRC

** YAML
Seriously if you have the choice, use json or even edn. If you don't, here's some syntax highlighting for yaml.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package yaml-mode
  :mode ("\\.yaml\\'" "\\.yml\\'"))
#+END_SRC

** Markdown
Like org but not as cool
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package markdown-mode
  :mode ("\\.md\\'" "\\.markdown\\'")
  :config (progn (add-hook 'markdown-mode-hook 'flyspell-mode)
                 (add-hook 'markdown-mode-hook 'yas-minor-mode)))
#+END_SRC

** Lua
Because 'X' won't mod itself
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package lua-mode
  :mode "\\.lua\\'")
#+END_SRC

** Zsh
Interpret the *many* zsh configuration scripts as zsh and recognize the =.zsh= file extension
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package sh-script
  :ensure t
  :config
  (let ((zsh-files '("zlogin" "zlogin" "zlogout" "zpreztorc"
                     "zprofile" "zshenv" "zshrc" ".zsh")))
    (add-to-list 'auto-mode-alist '("\\.zsh\\'" . shell-script-mode))
    (mapc (lambda (file)
            (add-to-list 'auto-mode-alist
                         `(,(format "\\%s\\'" file) . sh-mode)))
          zsh-files)
    (add-hook 'sh-mode-hook
              (lambda ()
                (when
                    (and buffer-file-name
                         (member (file-name-nondirectory buffer-file-name)
                                 zsh-files))
                  (sh-set-shell "zsh"))))))
#+END_SRC

** Terraform
Because why use something everyone's familiar with when you can create your own domain specific language?
I'm just sour because I think one should use scheme should to configure everything non-trivial. :-)
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package terraform-mode
  :mode ("\\.tf\\'" "\\.tvars\\'"))
#+END_SRC

* Software Distribution Specific Packages
Packages specific to different software distributions or systems.

** Arch
Search and fetch arch recipes from the AUR.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package aurel
  :when (executable-find "makepkg")
  :defer t)
#+END_SRC

** Guix
A build system / package manager / os definition system / waffle-iron all written in guile scheme.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package guix
  :when (executable-find "guix")
  :commands (guix)
  :bind (("s-x p" . guix)))
#+END_SRC

* Miscellaneous Packages
** Git
A version control tool created by Linus Torvalds

*** Magit
Magit is nice front-end to git. C-c m to open magit-status popup
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package magit
  :defer t
  :bind (:map global-map
              ("C-x g" . magit-status)))
#+END_SRC

*** Git file modes
Modes for editing git files e.g =.gitignore=
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package git-modes
  :defer t)
#+END_SRC

*** Mergetool
To use emacs as a git mergetool, you need to add something like the following to =~/.gitconfig=
#+BEGIN_EXAMPLE
[mergetool.ediff]
  cmd = emacsclient --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
[merge]
  tool = ediff
#+END_EXAMPLE

Cleanup ediff buffers and restore window configuration when finished.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package ediff
  :defer t
  :config
  (progn
    (defun mkyle/ediff-write-merge-buffer ()
      (let ((file ediff-merge-store-file))
        (set-buffer ediff-buffer-C)
        (write-region (point-min) (point-max) file)
        (message "Merge buffer saved in: %s" file)
        (set-buffer-modified-p nil)
        (sit-for 1)))
    (add-hook 'ediff-quit-merge-hook 'mkyle/ediff-write-merge-buffer)

    (defvar mkyle/ediff-last-windows nil)

    (defun mkyle/store-pre-ediff-winconfig ()
      (setq mkyle/ediff-last-windows (current-window-configuration)))
    (add-hook 'ediff-before-setup-hook 'mkyle/store-pre-ediff-winconfig)

    (defun mkyle/restore-pre-ediff-winconfig ()
      (dolist (buf (list ediff-buffer-A
                         ediff-buffer-B
                         ediff-buffer-C
                         "*Ediff Control Panel*"
                         "*ediff-errors*"
                         "*ediff-diff*"
                         "*Ediff Registry*"
                         "*ediff-fine-diff*"))
        (set-window-configuration mkyle/ediff-last-windows)
        (condition-case nil
            (let ((buf (get-buffer buf)))
              (when buf (kill-buffer buf)))
          (error nil))))

    (add-hook 'ediff-quit-hook 'mkyle/restore-pre-ediff-winconfig)

    (setq-default ediff-keep-variants nil)

    ;; Don't start a new frame
    (setq-default ediff-window-setup-function 'ediff-setup-windows-plain)))
#+END_SRC

** Restclient
make http requests with =C-c C-v=

See [[https://github.com/pashky/restclient.el][restclient github]] for user guide
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package restclient
  :mode ("\\.rest\\'" . restclient-mode))
#+END_SRC

** IRC
Internet relay chat appliance for emacs. Tune erc to use utf-8, truncate long buffers,
enable logging and other things.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package erc
  :defer t
  :commands (erc)
  :config
  (progn
    (setq erc-query-display 'buffer
          erc-interpret-mirc-color t
          erc-server-coding-system '(utf-8 . utf-8)
          erc-save-buffer-on-part t
          erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                    "324" "329" "332" "333" "353" "477"))

    (erc-truncate-mode +1)
    (erc-track-mode t)

    (when (require 'erc-log nil t)
      (unless (file-exists-p erc-log-channels-directory)
        (mkdir erc-log-channels-directory t)))

    (when (require 'erc-spelling nil t)
      (erc-spelling-mode 1))))
#+END_SRC

** Persistent Scratch
Save the scratch in case I write something down that shouldn't be in the scratch buffer
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package persistent-scratch
  :ensure t
  :diminish persistent-scratch-mode
  :config
  (progn
    (persistent-scratch-setup-default)
    (persistent-scratch-autosave-mode +1)))

(with-current-buffer "*scratch*"
  (persistent-scratch-mode +1))

(defun mkyle/scratch ()
  "Get or create the scratch buffer"
  (interactive)
  (unless (get-buffer "*scratch*")
    (persistent-scratch-restore)
    (with-current-buffer "*scratch*"
      (persistent-scratch-mode +1)))
  (let ((buf (get-buffer "*scratch*")))
    (if (eq buf (current-buffer))
        (bury-buffer)
      (switch-to-buffer buf))))

(global-set-key (kbd "s-x s") 'mkyle/scratch)
#+END_SRC

** Terminal
vterm is an integrated terminal emulator using modules.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package vterm
  :commands (vterm)
  :init (setq vterm-always-compile-module t
              vterm-buffer-name-string    "*vterm* %s"
              vterm-copy-mode-map
              (let ((map (make-sparse-keymap)))
                (define-key map (kbd "q")       'vterm-copy-mode-done)
                (define-key map (kbd "c")       'vterm-copy-mode-done)
                (define-key map (kbd "C-c C-c") 'vterm-copy-mode-done)
                (define-key map [return]        'vterm-copy-mode-done)
                (define-key map (kbd "RET")     'vterm-copy-mode-done)
                (define-key map (kbd "r")       'vterm-reset-cursor-point)
                (define-key map (kbd "a")       'vterm-beginning-of-line)
                (define-key map (kbd "e")       'vterm-end-of-line)
                (define-key map (kbd "n")       'vterm-next-prompt)
                (define-key map (kbd "p")       'vterm-previous-prompt)
                map))
  :config
  (progn
    ;; even with this hack it doesn't handle cua-mode very well
    (add-hook 'vterm-mode-hook (lambda ()
                                 (linum-mode -1)
                                 (setq-local cua-enable-cua-keys nil)
                                 (local-set-key (kbd "C-v") 'vterm-yank)
                                 (local-set-key (kbd "C-z") 'vterm-undo)))

    (with-eval-after-load 'ibuffer-dynamic-groups
      (ibuffer-dynamic-groups-add (lambda (groups)
                                    (append '(("Terminals" (mode . vterm-mode)))
                                            groups))
                                  '((name . vterm-group)
                                    (depth . -9))))))

(defun mkyle/vterm-execute (command)
  "Start a vterm session with the given command"
  (interactive (list (read-shell-command "$ ")))
  (let ((vterm-shell command))
    (vterm)))
#+END_SRC

*** vtplex
Terminal multiplexer for vterm. It uses similar keybindings to gnu screen.
#+begin_src emacs-lisp :tangle init.el
(use-package vtplex
  :straight (vtplex :type   git
                    :host   github
                    :repo   "mitch-kyle/vtplex"
                    :branch "main")
  :after vterm
  :commands (vtplex vtplex-mode vtplex-execute)
  :bind (:map global-map
              ("s-<return>" . vtplex)
              ("s-!" .        vtplex-execute))
  :config
  (progn (require 'vtplex-spaceline)
         (vtplex-spaceline-enable 'mkyle/projectile)))

#+end_src

** External Applications
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun mkyle/run-sh-async (&optional command)
  "Interactive prompt to run a shell command in a child process which
may or may not spawn an x window"
  (interactive (list (read-shell-command "$ ")))
  (when command
    (start-process-shell-command "" nil command)))

(global-set-key (kbd "s-`") #'mkyle/run-sh-async)
#+END_SRC

*** Persistent Buffers
Used for tracking the vterm buffers running the volume and music apps

#+BEGIN_SRC emacs-lisp :tangle init.el
(defvar mkyle/labeled-buffers (make-hash-table :weakness 'value))

(defun mkyle/labeled-buffer (label create-new)
  "switch to labeled buffer if buffer does not exist create it by
invoking `create-new'."
  (let ((buf (gethash label mkyle/labeled-buffers)))
    (if (and buf (buffer-live-p buf))
        (switch-to-buffer buf)
      (funcall create-new)
      (puthash label (current-buffer) mkyle/labeled-buffers)
      nil)))
#+END_SRC

*** Volume
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun mkyle/volume ()
  (interactive)
  (mkyle/labeled-buffer 'mkyle/volume
                        (lambda ()
                          (let ((vterm-shell (if (executable-find "pulsemixer")
                                                 "pulsemixer"
                                               "alsamixer"))
                                (vterm-buffer-name-string "*volume* - %s"))
                            (vterm)))))

(defun mkyle/volume-down ()
  (interactive)
  (start-process-shell-command "" nil "amixer set Master 5%-"))

(defun mkyle/volume-up ()
  (interactive)
  (start-process-shell-command "" nil "amixer set Master 5%+"))

(defun mkyle/volume-mute ()
  (interactive)
  (start-process-shell-command "" nil "amixer set Master toggle"))

(defun mkyle/volume-mute-mic ()
  (interactive)
  (start-process-shell-command "" nil "amixer set Mic toggle"))

(global-set-key (kbd "s-x v") 'mkyle/volume)
#+END_SRC

*** Music
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun mkyle/music ()
  (interactive)
  (mkyle/labeled-buffer 'mkyle/music
                        (lambda ()
                          (let ((vterm-shell "ncmpcpp -s playlist -S visualizer")
                                (vterm-buffer-name-string "*music* - %s"))
                            (vterm)))))

(defun mkyle/music-next ()
  (interactive)
  (start-process-shell-command "" nil "mpc next"))

(defun mkyle/music-prev ()
  (interactive)
  (start-process-shell-command "" nil "mpc prev"))

(defun mkyle/music-toggle ()
  (interactive)
  (start-process-shell-command "" nil "mpc toggle"))

(global-set-key (kbd "s-x m") 'mkyle/music)
#+END_SRC

** Window Manager - EXWM
"You did it. You're free" - Janet Carr, sarcastically, when I told her I started using emacs as a window
manager.
See: [[./window-manager.org][window-manager.org]]
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package exwm
  ;; TODO find test for emacs on root window to put here
  :if window-system
  :after no-littering
  :commands (exwm-init exwm-enable)
  :defer t
  :config
  (require 'window-manager
           (expand-file-name "window-manager.elc"
                             user-emacs-directory)
           t))
#+END_SRC

* User Script Directory
Any emacs lisp files placed ~~/.emacs.d/lisp~ will be loaded
#+BEGIN_SRC emacs-lisp :tangle init.el
(defvar mkyle/user-lisp-directory
  (expand-file-name "lisp"
                    user-emacs-directory)
  "All emacs lisp files in this directory will be loaded during initialization. default is ~/.emacs.d/lisp.")

(use-package load-directory
  :config
  (when (file-directory-p mkyle/user-lisp-directory)
    (load-directory mkyle/user-lisp-directory t)))
#+END_SRC

* Footer
Add a marker so we know where the file ends.
#+BEGIN_SRC emacs-lisp :tangle init.el
;; init.el ends here
#+END_SRC

* Tasks
** TODO Recompile on save

# readme.org ends here
