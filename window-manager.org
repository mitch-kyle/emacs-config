#+TITLE: Window Manager - EXWM Configuration
#+AUTHOR: Mitch Kyle

* Just, Why?
The exwm package allows you to use emacs as a window manager if it's ran as the
root X window.I started using it for laugh then it became not a joke. Basically,
one day I walked into emacs and didn't walk out.

** Compile This File
in emacs:
#+BEGIN_EXAMPLE
C-u M-x org-babel-load-file RET path/to/window-manager.org
#+END_EXAMPLE

* Table Of Contents :TOC_3:
- [[#just-why][Just, Why?]]
  - [[#compile-this-file][Compile This File]]
- [[#header][Header]]
- [[#guts][Guts]]
  - [[#initial-configuration][Initial Configuration]]
  - [[#multiple-monitors][Multiple Monitors]]
    - [[#navigate-between-monitors][Navigate Between Monitors]]
    - [[#move-buffers-between-monitors][Move Buffers Between Monitors]]
  - [[#buffer-names][Buffer Names]]
  - [[#system-tray][System Tray]]
  - [[#mode-line][Mode Line]]
    - [[#date-and-time][Date and Time]]
    - [[#battery][Battery]]
  - [[#ibuffer-group][IBuffer Group]]
- [[#applications][Applications]]
  - [[#browser][Browser]]
  - [[#taking-screenshots][Taking Screenshots]]
  - [[#screen-lock][Screen Lock]]
- [[#keybindings][Keybindings]]
  - [[#simulation-keys][Simulation Keys]]
- [[#footer][Footer]]

* Header
Enable lexical binding and print generated file disclaimer
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
;;; window-manager.el --- exwm configuration -*- lexical-binding: t; -*-
;;; Commentary:
;; This file was generated. do not edit. changes may be overwritten
;;; Code:
#+END_SRC

* Guts
** Initial Configuration
This loads up all the builtin configuration in the library.
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(require 'exwm)
(require 'exwm-config)
(require 'server)

(exwm-config-example)
(exwm-enable)


(unless (server-running-p)
  (server-start))
#+END_SRC

** Multiple Monitors
Automatically create new workspaces when monitors are added or removed.
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(require 'exwm-randr)
(defun wm/xrandr-update-outputs ()
  (let ((monitors   (let ((reg "^\\([^ ]*?\\) connected")
                          (str (shell-command-to-string "xrandr"))
                          (pos 0)
                          (res))
                      (while (setq pos (string-match reg str (1+ pos)))
                        (push (match-string 1 str) res))
                      (nreverse res)))
        (i 0)
        (result))
    (dolist (m monitors result)
      (setq result (plist-put result m i)
            i      (1+ i)))
    (while (> i (exwm-workspace--count))
      (exwm-workspace-add))
    (setq exwm-randr-workspace-monitor-plist (nreverse result))))

(defun wm/xrandr-init ()
  (add-hook 'exwm-randr-screen-change-hook 'wm/xrandr-update-outputs)
  (wm/xrandr-update-outputs)
  (exwm-randr--init))

(defun wm/xrandr-exit ()
  (remove-hook 'exwm-randr-screen-change-hook 'wm/xrandr-update-outputs)
  (exwm-randr--exit))

(add-hook 'exwm-init-hook #'wm/xrandr-init)
(add-hook 'exwm-exit-hook #'wm/xrandr-exit)
#+END_SRC

*** Navigate Between Monitors
Since workspace are just frames we can move between them the magic library
called framemove which hooks into windmove and works pretty seamlessly.
In theory, in practice we need to do some monkeying to get it working.
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(use-package framemove
  :after windmove
  :init (progn (require 'seq)
               (defalias 'remove-if-not 'seq-filter))
  :config
  (progn
    (require 'windmove)
    (defun mkyle/windmove-framemove-hook (f dir &optional arg window)
      "Hook windmove to framemove properly"
      (condition-case nil
          (funcall f dir arg window)
        ('error (fm-next-frame dir))))

    (advice-add 'windmove-do-window-select
                :around
                #'mkyle/windmove-framemove-hook)))
#+END_SRC

Also make sure windmove bindings are avilable in exwm buffers
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(exwm-input-set-key (kbd "s-<left>") #'windmove-left)
(exwm-input-set-key (kbd "s-<right>") #'windmove-right)
(exwm-input-set-key (kbd "s-<up>") #'windmove-up)
(exwm-input-set-key (kbd "s-<down>") #'windmove-down)
#+END_SRC

*** Move Buffers Between Monitors
We're not gonna use workspaces for anything besides multimonitor support
so disable workspace isolation.
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(setq exwm-workspace-show-all-buffers t
      exwm-layout-show-all-buffers    t)
#+END_SRC

** Buffer Names
Having a bunch of buffers named EXWM isn't helpful so let's make it the xwindow
title. Don't ask me why this isn't the default behaviour.
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(defun wm/rename-buffer ()
  (interactive)
  (exwm-workspace-rename-buffer
   (concat exwm-class-name ": "
           (if (<= (length exwm-title) 50)
               exwm-title
             (concat (substring exwm-title 0 49) "...")))))

(add-hook 'exwm-update-class-hook 'wm/rename-buffer)
(add-hook 'exwm-update-title-hook 'wm/rename-buffer)
#+END_SRC

** System Tray
Show the system tray in the bottom right corner.
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(require 'exwm-systemtray)
(exwm-systemtray-enable)
#+END_SRC

** Mode Line
Add some extra information that would normally be in the window manager panel.

*** Date and Time
Show the date and time
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(setq display-time-day-and-date t
      display-time-default-load-average nil)
(display-time-mode t)
#+END_SRC

*** Battery
Show the battery level and charging status.
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(use-package fancy-battery
  :hook ((exwm-init-hook) . fancy-batter-mode))

#+END_SRC

** IBuffer Group
It's nice to have all the xwindows in their own ibuffer group so you aren't
hunting for them.
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(with-eval-after-load 'ibuffer-dynamic-groups
  (ibuffer-dynamic-groups-add (lambda (groups)
                                (append '(("X Windows" (mode . exwm-mode)))
                                        groups))
                              '((name . exwm-group)
                                (depth . -10))))
#+END_SRC

* Applications
** Browser
For browsin...
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(require 'seq)

(defun wm/browser ()
  "Run, raise, or bury browser window"
  (interactive)
  (if-let (buf (seq-find (lambda (buffer)
                           (with-current-buffer buffer
                             (and (eq major-mode 'exwm-mode)
                                  (string= exwm-class-name "firefox")
                                  (buffer-live-p buffer)
                                  buffer)))
                         (buffer-list)))
      (if (equal buf (current-buffer))
          (bury-buffer)
        (switch-to-buffer buf))
    (start-process-shell-command "firefox" nil "firefox")))
#+END_SRC

** Taking Screenshots
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(defun wm/scrot ()
  (interactive)
  (start-process-shell-command "" nil
                               "scrot --select --exec 'mv $f ~/Pictures/screenshots'"))
#+END_SRC

** Screen Lock
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(defun wm/lock ()
  (interactive)
  (start-process-shell-command "" nil "dm-tool lock"))
#+END_SRC

* Keybindings
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
;; Enable or disable other emacs keybindings in exwm windows
(exwm-input-set-key (kbd "s-SPC") 'exwm-input-toggle-keyboard)

;; Send the next key without it being captured by emacs
(exwm-input-set-key (kbd "C-q") 'exwm-input-send-next-key)

;; Floating Windows
(exwm-input-set-key (kbd "C-c f") 'exwm-floating-toggle-floating)

;; Do stuff
(exwm-input-set-key (kbd "s-`")        'mkyle/run-sh-async)
(exwm-input-set-key (kbd "s-!")        'vtplex-execute)
(exwm-input-set-key (kbd "s-<return>") 'vtplex)
(add-to-list 'exwm-input-prefix-keys 's-return) ;; Needed to capture key

;; Apps
(exwm-input-set-key (kbd "s-x i")             'wm/browser)
(exwm-input-set-key (kbd "s-x v")             'mkyle/volume)
(exwm-input-set-key (kbd "s-x l")             'wm/lock)
(exwm-input-set-key (kbd "<XF86Launch1>")     'wm/scrot)
(exwm-input-set-key (kbd "<XF86ScreenSaver>") 'wm/lock)

;; Music
(exwm-input-set-key (kbd "s-x m")           'mkyle/music)
(exwm-input-set-key (kbd "s-x M-<down>")    'mkyle/music-toggle)
(exwm-input-set-key (kbd "s-x M-<left>")    'mkyle/music-prev)
(exwm-input-set-key (kbd "s-x M-<right>")   'mkyle/music-next)
(exwm-input-set-key (kbd "<XF86AudioPlay>") 'mkyle/music-toggle)
(exwm-input-set-key (kbd "<XF86AudioNext>") 'mkyle/music-next)
(exwm-input-set-key (kbd "<XF86AudioPrev>") 'mkyle/music-prev)

;; Some laptops put playback symbols on other keys for some reason
(exwm-input-set-key (kbd "<XF86LaunchA>")   'mkyle/music-toggle)
(exwm-input-set-key (kbd "<XF86Search>")    'mkyle/music-prev)
(exwm-input-set-key (kbd "<XF86Explorer>")  'mkyle/music-next)

;; Audio Control
(exwm-input-set-key (kbd "<XF86AudioRaiseVolume>") 'mkyle/volume-up)
(exwm-input-set-key (kbd "<XF86AudioLowerVolume>") 'mkyle/volume-down)
(exwm-input-set-key (kbd "<XF86AudioMute>")        'mkyle/volume-mute)
(exwm-input-set-key (kbd "<XF86AudioMicMute>")     'mkyle/volume-mute-mic)

;; These work in outside the window manager so don't need warning about undefined
(let ((noop (lambda () (interactive))))
  (exwm-input-set-key (kbd "<XF86MonBrightnessDown>") noop)
  (exwm-input-set-key (kbd "<XF86MonBrightnessUp>")   noop)
  (exwm-input-set-key (kbd "<XF86Sleep>")             noop)
  (exwm-input-set-key (kbd "<XF86WLAN>")              noop))
#+END_SRC

** Simulation Keys
In exwm buffers we want to map some common keybindings to their emacs equivalent
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(setq-default exwm-input-simulation-keys
              '(([?\C-s]       . [?\C-f])))
#+END_SRC

* Footer
#+BEGIN_SRC emacs-lisp :tangle window-manager.el
(exwm-enable)
(provide 'window-manager)
;;; window-manager.el ends here
#+END_SRC
